<?xml version="1.0" encoding="utf-8"?><testsuites><testsuite name="pytest" errors="2" failures="2" skipped="1" tests="70" time="5.293" timestamp="2021-06-12T22:59:01.498118" hostname="LAPTOP-9MKQQPJI"><testcase classname="tests.test_order" name="test_bar" time="1.225" /><testcase classname="tests.test_order" name="test_foo" time="0.001" /><testcase classname="tests.test_container" name="test_smoke" time="0.010" /><testcase classname="tests.test_container" name="test_regression" time="0.009" /><testcase classname="tests.test_demo1" name="test_firstProgram" time="0.006" /><testcase classname="tests.test_demo1" name="test_secondgreetcreditCard" time="0.002" /><testcase classname="tests.test_demo1" name="test_crossbrowser[crossbrowser0]" time="0.003" /><testcase classname="tests.test_demo1" name="test_crossbrowser[crossbrowser1]" time="0.002" /><testcase classname="tests.test_demo1" name="test_crossbrowser[crossbrowser2]" time="0.003" /><testcase classname="tests.test_demo2" name="test_firstprogram" time="0.001"><skipped type="pytest.skip" message="unconditional skip">C:\PycharmProjects\pomproject\tests\test_demo2.py:4: unconditional skip</skipped></testcase><testcase classname="tests.test_demo2" name="test_secondcreditcard" time="0.002" /><testcase classname="tests.test_fixturedata.TestExample2" name="test_editprofile" time="0.009" /><testcase classname="tests.test_fixturedemo.TestExample" name="test_fixturedemo" time="0.005" /><testcase classname="tests.test_fixturedemo.TestExample" name="test_fixturedemo1" time="0.003" /><testcase classname="tests.test_fixturedemo.TestExample" name="test_fixturedemo2" time="0.002" /><testcase classname="tests.test_fixturedemo.TestExample" name="test_fixturedemo3" time="0.003" /><testcase classname="tests.test_flaky" name="test_example1" time="0.003" /><testcase classname="tests.test_flaky" name="test_example" time="0.003" /><testcase classname="tests.test_home_page_title.TestHomePageTitle" name="test_login_page_title" time="0.015"><error message="failed on setup with &quot;selenium.common.exceptions.WebDriverException: Message: 'chromedriver' executable needs to be in PATH. Please see https://sites.google.com/a/chromium.org/chromedriver/home&quot;">self = &lt;selenium.webdriver.chrome.service.Service object at 0x000001C88E7CF880&gt;

    def start(self):
        """
        Starts the Service.
    
        :Exceptions:
         - WebDriverException : Raised either when it can't start the service
           or when it can't connect to the service
        """
        try:
            cmd = [self.path]
            cmd.extend(self.command_line_args())
&gt;           self.process = subprocess.Popen(cmd, env=self.env,
                                            close_fds=platform.system() != 'Windows',
                                            stdout=self.log_file,
                                            stderr=self.log_file,
                                            stdin=PIPE)

c:\python39\lib\site-packages\selenium\webdriver\common\service.py:72: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;Popen: returncode: None args: ['chromedriver', '--port=56984']&gt;, args = ['chromedriver', '--port=56984']
bufsize = -1, executable = None, stdin = -1, stdout = -3, stderr = -3, preexec_fn = None, close_fds = False
shell = False, cwd = None
env = environ({'ALLUSERSPROFILE': 'C:\\ProgramData', 'APPDATA': 'C:\\Users\\vishr\\AppData\\Roaming', 'CHOCOLATEYINSTALL': '...:\\WINDOWS', 'PYTEST_CURRENT_TEST': 'tests/test_home_page_title.py::TestHomePageTitle::test_login_page_title (setup)'})
universal_newlines = None, startupinfo = None, creationflags = 0, restore_signals = True, start_new_session = False
pass_fds = ()

    def __init__(self, args, bufsize=-1, executable=None,
                 stdin=None, stdout=None, stderr=None,
                 preexec_fn=None, close_fds=True,
                 shell=False, cwd=None, env=None, universal_newlines=None,
                 startupinfo=None, creationflags=0,
                 restore_signals=True, start_new_session=False,
                 pass_fds=(), *, user=None, group=None, extra_groups=None,
                 encoding=None, errors=None, text=None, umask=-1):
        """Create new Popen instance."""
        _cleanup()
        # Held while anything is calling waitpid before returncode has been
        # updated to prevent clobbering returncode if wait() or poll() are
        # called from multiple threads at once.  After acquiring the lock,
        # code must re-check self.returncode to see if another thread just
        # finished a waitpid() call.
        self._waitpid_lock = threading.Lock()
    
        self._input = None
        self._communication_started = False
        if bufsize is None:
            bufsize = -1  # Restore default
        if not isinstance(bufsize, int):
            raise TypeError("bufsize must be an integer")
    
        if _mswindows:
            if preexec_fn is not None:
                raise ValueError("preexec_fn is not supported on Windows "
                                 "platforms")
        else:
            # POSIX
            if pass_fds and not close_fds:
                warnings.warn("pass_fds overriding close_fds.", RuntimeWarning)
                close_fds = True
            if startupinfo is not None:
                raise ValueError("startupinfo is only supported on Windows "
                                 "platforms")
            if creationflags != 0:
                raise ValueError("creationflags is only supported on Windows "
                                 "platforms")
    
        self.args = args
        self.stdin = None
        self.stdout = None
        self.stderr = None
        self.pid = None
        self.returncode = None
        self.encoding = encoding
        self.errors = errors
    
        # Validate the combinations of text and universal_newlines
        if (text is not None and universal_newlines is not None
            and bool(universal_newlines) != bool(text)):
            raise SubprocessError('Cannot disambiguate when both text '
                                  'and universal_newlines are supplied but '
                                  'different. Pass one or the other.')
    
        # Input and output objects. The general principle is like
        # this:
        #
        # Parent                   Child
        # ------                   -----
        # p2cwrite   ---stdin---&gt;  p2cread
        # c2pread    &lt;--stdout---  c2pwrite
        # errread    &lt;--stderr---  errwrite
        #
        # On POSIX, the child objects are file descriptors.  On
        # Windows, these are Windows file handles.  The parent objects
        # are file descriptors on both platforms.  The parent objects
        # are -1 when not using PIPEs. The child objects are -1
        # when not redirecting.
    
        (p2cread, p2cwrite,
         c2pread, c2pwrite,
         errread, errwrite) = self._get_handles(stdin, stdout, stderr)
    
        # We wrap OS handles *before* launching the child, otherwise a
        # quickly terminating child could make our fds unwrappable
        # (see #8458).
    
        if _mswindows:
            if p2cwrite != -1:
                p2cwrite = msvcrt.open_osfhandle(p2cwrite.Detach(), 0)
            if c2pread != -1:
                c2pread = msvcrt.open_osfhandle(c2pread.Detach(), 0)
            if errread != -1:
                errread = msvcrt.open_osfhandle(errread.Detach(), 0)
    
        self.text_mode = encoding or errors or text or universal_newlines
    
        # How long to resume waiting on a child after the first ^C.
        # There is no right value for this.  The purpose is to be polite
        # yet remain good for interactive users trying to exit a tool.
        self._sigint_wait_secs = 0.25  # 1/xkcd221.getRandomNumber()
    
        self._closed_child_pipe_fds = False
    
        if self.text_mode:
            if bufsize == 1:
                line_buffering = True
                # Use the default buffer size for the underlying binary streams
                # since they don't support line buffering.
                bufsize = -1
            else:
                line_buffering = False
    
        gid = None
        if group is not None:
            if not hasattr(os, 'setregid'):
                raise ValueError("The 'group' parameter is not supported on the "
                                 "current platform")
    
            elif isinstance(group, str):
                if grp is None:
                    raise ValueError("The group parameter cannot be a string "
                                     "on systems without the grp module")
    
                gid = grp.getgrnam(group).gr_gid
            elif isinstance(group, int):
                gid = group
            else:
                raise TypeError("Group must be a string or an integer, not {}"
                                .format(type(group)))
    
            if gid &lt; 0:
                raise ValueError(f"Group ID cannot be negative, got {gid}")
    
        gids = None
        if extra_groups is not None:
            if not hasattr(os, 'setgroups'):
                raise ValueError("The 'extra_groups' parameter is not "
                                 "supported on the current platform")
    
            elif isinstance(extra_groups, str):
                raise ValueError("Groups must be a list, not a string")
    
            gids = []
            for extra_group in extra_groups:
                if isinstance(extra_group, str):
                    if grp is None:
                        raise ValueError("Items in extra_groups cannot be "
                                         "strings on systems without the "
                                         "grp module")
    
                    gids.append(grp.getgrnam(extra_group).gr_gid)
                elif isinstance(extra_group, int):
                    gids.append(extra_group)
                else:
                    raise TypeError("Items in extra_groups must be a string "
                                    "or integer, not {}"
                                    .format(type(extra_group)))
    
            # make sure that the gids are all positive here so we can do less
            # checking in the C code
            for gid_check in gids:
                if gid_check &lt; 0:
                    raise ValueError(f"Group ID cannot be negative, got {gid_check}")
    
        uid = None
        if user is not None:
            if not hasattr(os, 'setreuid'):
                raise ValueError("The 'user' parameter is not supported on "
                                 "the current platform")
    
            elif isinstance(user, str):
                if pwd is None:
                    raise ValueError("The user parameter cannot be a string "
                                     "on systems without the pwd module")
    
                uid = pwd.getpwnam(user).pw_uid
            elif isinstance(user, int):
                uid = user
            else:
                raise TypeError("User must be a string or an integer")
    
            if uid &lt; 0:
                raise ValueError(f"User ID cannot be negative, got {uid}")
    
        try:
            if p2cwrite != -1:
                self.stdin = io.open(p2cwrite, 'wb', bufsize)
                if self.text_mode:
                    self.stdin = io.TextIOWrapper(self.stdin, write_through=True,
                            line_buffering=line_buffering,
                            encoding=encoding, errors=errors)
            if c2pread != -1:
                self.stdout = io.open(c2pread, 'rb', bufsize)
                if self.text_mode:
                    self.stdout = io.TextIOWrapper(self.stdout,
                            encoding=encoding, errors=errors)
            if errread != -1:
                self.stderr = io.open(errread, 'rb', bufsize)
                if self.text_mode:
                    self.stderr = io.TextIOWrapper(self.stderr,
                            encoding=encoding, errors=errors)
    
&gt;           self._execute_child(args, executable, preexec_fn, close_fds,
                                pass_fds, cwd, env,
                                startupinfo, creationflags, shell,
                                p2cread, p2cwrite,
                                c2pread, c2pwrite,
                                errread, errwrite,
                                restore_signals,
                                gid, gids, uid, umask,
                                start_new_session)

c:\python39\lib\subprocess.py:951: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;Popen: returncode: None args: ['chromedriver', '--port=56984']&gt;, args = 'chromedriver --port=56984'
executable = None, preexec_fn = None, close_fds = False, pass_fds = (), cwd = None
env = environ({'ALLUSERSPROFILE': 'C:\\ProgramData', 'APPDATA': 'C:\\Users\\vishr\\AppData\\Roaming', 'CHOCOLATEYINSTALL': '...:\\WINDOWS', 'PYTEST_CURRENT_TEST': 'tests/test_home_page_title.py::TestHomePageTitle::test_login_page_title (setup)'})
startupinfo = &lt;subprocess.STARTUPINFO object at 0x000001C88E7CF0A0&gt;, creationflags = 0, shell = False
p2cread = Handle(780), p2cwrite = 7, c2pread = -1, c2pwrite = Handle(816), errread = -1, errwrite = Handle(812)
unused_restore_signals = True, unused_gid = None, unused_gids = None, unused_uid = None, unused_umask = -1
unused_start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       unused_restore_signals,
                       unused_gid, unused_gids, unused_uid,
                       unused_umask,
                       unused_start_new_session):
        """Execute program (MS Windows version)"""
    
        assert not pass_fds, "pass_fds not supported on Windows."
    
        if isinstance(args, str):
            pass
        elif isinstance(args, bytes):
            if shell:
                raise TypeError('bytes args is not allowed on Windows')
            args = list2cmdline([args])
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = list2cmdline([args])
        else:
            args = list2cmdline(args)
    
        if executable is not None:
            executable = os.fsdecode(executable)
    
        # Process startup details
        if startupinfo is None:
            startupinfo = STARTUPINFO()
        else:
            # bpo-34044: Copy STARTUPINFO since it is modified above,
            # so the caller can reuse it multiple times.
            startupinfo = startupinfo.copy()
    
        use_std_handles = -1 not in (p2cread, c2pwrite, errwrite)
        if use_std_handles:
            startupinfo.dwFlags |= _winapi.STARTF_USESTDHANDLES
            startupinfo.hStdInput = p2cread
            startupinfo.hStdOutput = c2pwrite
            startupinfo.hStdError = errwrite
    
        attribute_list = startupinfo.lpAttributeList
        have_handle_list = bool(attribute_list and
                                "handle_list" in attribute_list and
                                attribute_list["handle_list"])
    
        # If we were given an handle_list or need to create one
        if have_handle_list or (use_std_handles and close_fds):
            if attribute_list is None:
                attribute_list = startupinfo.lpAttributeList = {}
            handle_list = attribute_list["handle_list"] = \
                list(attribute_list.get("handle_list", []))
    
            if use_std_handles:
                handle_list += [int(p2cread), int(c2pwrite), int(errwrite)]
    
            handle_list[:] = self._filter_handle_list(handle_list)
    
            if handle_list:
                if not close_fds:
                    warnings.warn("startupinfo.lpAttributeList['handle_list'] "
                                  "overriding close_fds", RuntimeWarning)
    
                # When using the handle_list we always request to inherit
                # handles but the only handles that will be inherited are
                # the ones in the handle_list
                close_fds = False
    
        if shell:
            startupinfo.dwFlags |= _winapi.STARTF_USESHOWWINDOW
            startupinfo.wShowWindow = _winapi.SW_HIDE
            comspec = os.environ.get("COMSPEC", "cmd.exe")
            args = '{} /c "{}"'.format (comspec, args)
    
        if cwd is not None:
            cwd = os.fsdecode(cwd)
    
        sys.audit("subprocess.Popen", executable, args, cwd, env)
    
        # Start the process
        try:
&gt;           hp, ht, pid, tid = _winapi.CreateProcess(executable, args,
                                     # no special security
                                     None, None,
                                     int(not close_fds),
                                     creationflags,
                                     env,
                                     cwd,
                                     startupinfo)
E                                    FileNotFoundError: [WinError 2] The system cannot find the file specified

c:\python39\lib\subprocess.py:1420: FileNotFoundError

During handling of the above exception, another exception occurred:

request = &lt;SubRequest 'driver_setup' for &lt;Function test_login_page_title&gt;&gt;

    @pytest.fixture(scope="module")
    def driver_setup(request):
        global driver
        print('-' * 10 + 'Driver - Setup' + '-' * 10)
        browser_name = request.config.getoption("browser_name")
        browser_name = browser_name.upper()
        if browser_name == "CHROME" and s.DOCKER == 'N':
            driver = webdriver.Chrome(ChromeDriverManager().install())
        elif browser_name == "CHROME" and s.DOCKER == 'Y':
            chrome_options = Options()
            chrome_options.add_argument("--headless")
            chrome_options.add_argument("--no-sandbox")
            chrome_options.add_argument("--disable-dev-shm-usage")
            chrome_prefs = {}
            chrome_options.experimental_options["prefs"] = chrome_prefs
            chrome_prefs["profile.default_content_settings"] = {"images": 2}
&gt;           driver = webdriver.Chrome(options=chrome_options)

tests\conftest.py:35: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
c:\python39\lib\site-packages\selenium\webdriver\chrome\webdriver.py:73: in __init__
    self.service.start()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;selenium.webdriver.chrome.service.Service object at 0x000001C88E7CF880&gt;

    def start(self):
        """
        Starts the Service.
    
        :Exceptions:
         - WebDriverException : Raised either when it can't start the service
           or when it can't connect to the service
        """
        try:
            cmd = [self.path]
            cmd.extend(self.command_line_args())
            self.process = subprocess.Popen(cmd, env=self.env,
                                            close_fds=platform.system() != 'Windows',
                                            stdout=self.log_file,
                                            stderr=self.log_file,
                                            stdin=PIPE)
        except TypeError:
            raise
        except OSError as err:
            if err.errno == errno.ENOENT:
&gt;               raise WebDriverException(
                    "'%s' executable needs to be in PATH. %s" % (
                        os.path.basename(self.path), self.start_error_message)
E                       selenium.common.exceptions.WebDriverException: Message: 'chromedriver' executable needs to be in PATH. Please see https://sites.google.com/a/chromium.org/chromedriver/home

c:\python39\lib\site-packages\selenium\webdriver\common\service.py:81: WebDriverException</error></testcase><testcase classname="tests.test_login_page_title.TestLoginPageTitle" name="test_login_page_title" time="0.004"><error message="failed on setup with &quot;selenium.common.exceptions.WebDriverException: Message: 'chromedriver' executable needs to be in PATH. Please see https://sites.google.com/a/chromium.org/chromedriver/home&quot;">self = &lt;selenium.webdriver.chrome.service.Service object at 0x000001C88E7648B0&gt;

    def start(self):
        """
        Starts the Service.
    
        :Exceptions:
         - WebDriverException : Raised either when it can't start the service
           or when it can't connect to the service
        """
        try:
            cmd = [self.path]
            cmd.extend(self.command_line_args())
&gt;           self.process = subprocess.Popen(cmd, env=self.env,
                                            close_fds=platform.system() != 'Windows',
                                            stdout=self.log_file,
                                            stderr=self.log_file,
                                            stdin=PIPE)

c:\python39\lib\site-packages\selenium\webdriver\common\service.py:72: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;Popen: returncode: None args: ['chromedriver', '--port=56985']&gt;, args = ['chromedriver', '--port=56985']
bufsize = -1, executable = None, stdin = -1, stdout = -3, stderr = -3, preexec_fn = None, close_fds = False
shell = False, cwd = None
env = environ({'ALLUSERSPROFILE': 'C:\\ProgramData', 'APPDATA': 'C:\\Users\\vishr\\AppData\\Roaming', 'CHOCOLATEYINSTALL': '...\WINDOWS', 'PYTEST_CURRENT_TEST': 'tests/test_login_page_title.py::TestLoginPageTitle::test_login_page_title (setup)'})
universal_newlines = None, startupinfo = None, creationflags = 0, restore_signals = True, start_new_session = False
pass_fds = ()

    def __init__(self, args, bufsize=-1, executable=None,
                 stdin=None, stdout=None, stderr=None,
                 preexec_fn=None, close_fds=True,
                 shell=False, cwd=None, env=None, universal_newlines=None,
                 startupinfo=None, creationflags=0,
                 restore_signals=True, start_new_session=False,
                 pass_fds=(), *, user=None, group=None, extra_groups=None,
                 encoding=None, errors=None, text=None, umask=-1):
        """Create new Popen instance."""
        _cleanup()
        # Held while anything is calling waitpid before returncode has been
        # updated to prevent clobbering returncode if wait() or poll() are
        # called from multiple threads at once.  After acquiring the lock,
        # code must re-check self.returncode to see if another thread just
        # finished a waitpid() call.
        self._waitpid_lock = threading.Lock()
    
        self._input = None
        self._communication_started = False
        if bufsize is None:
            bufsize = -1  # Restore default
        if not isinstance(bufsize, int):
            raise TypeError("bufsize must be an integer")
    
        if _mswindows:
            if preexec_fn is not None:
                raise ValueError("preexec_fn is not supported on Windows "
                                 "platforms")
        else:
            # POSIX
            if pass_fds and not close_fds:
                warnings.warn("pass_fds overriding close_fds.", RuntimeWarning)
                close_fds = True
            if startupinfo is not None:
                raise ValueError("startupinfo is only supported on Windows "
                                 "platforms")
            if creationflags != 0:
                raise ValueError("creationflags is only supported on Windows "
                                 "platforms")
    
        self.args = args
        self.stdin = None
        self.stdout = None
        self.stderr = None
        self.pid = None
        self.returncode = None
        self.encoding = encoding
        self.errors = errors
    
        # Validate the combinations of text and universal_newlines
        if (text is not None and universal_newlines is not None
            and bool(universal_newlines) != bool(text)):
            raise SubprocessError('Cannot disambiguate when both text '
                                  'and universal_newlines are supplied but '
                                  'different. Pass one or the other.')
    
        # Input and output objects. The general principle is like
        # this:
        #
        # Parent                   Child
        # ------                   -----
        # p2cwrite   ---stdin---&gt;  p2cread
        # c2pread    &lt;--stdout---  c2pwrite
        # errread    &lt;--stderr---  errwrite
        #
        # On POSIX, the child objects are file descriptors.  On
        # Windows, these are Windows file handles.  The parent objects
        # are file descriptors on both platforms.  The parent objects
        # are -1 when not using PIPEs. The child objects are -1
        # when not redirecting.
    
        (p2cread, p2cwrite,
         c2pread, c2pwrite,
         errread, errwrite) = self._get_handles(stdin, stdout, stderr)
    
        # We wrap OS handles *before* launching the child, otherwise a
        # quickly terminating child could make our fds unwrappable
        # (see #8458).
    
        if _mswindows:
            if p2cwrite != -1:
                p2cwrite = msvcrt.open_osfhandle(p2cwrite.Detach(), 0)
            if c2pread != -1:
                c2pread = msvcrt.open_osfhandle(c2pread.Detach(), 0)
            if errread != -1:
                errread = msvcrt.open_osfhandle(errread.Detach(), 0)
    
        self.text_mode = encoding or errors or text or universal_newlines
    
        # How long to resume waiting on a child after the first ^C.
        # There is no right value for this.  The purpose is to be polite
        # yet remain good for interactive users trying to exit a tool.
        self._sigint_wait_secs = 0.25  # 1/xkcd221.getRandomNumber()
    
        self._closed_child_pipe_fds = False
    
        if self.text_mode:
            if bufsize == 1:
                line_buffering = True
                # Use the default buffer size for the underlying binary streams
                # since they don't support line buffering.
                bufsize = -1
            else:
                line_buffering = False
    
        gid = None
        if group is not None:
            if not hasattr(os, 'setregid'):
                raise ValueError("The 'group' parameter is not supported on the "
                                 "current platform")
    
            elif isinstance(group, str):
                if grp is None:
                    raise ValueError("The group parameter cannot be a string "
                                     "on systems without the grp module")
    
                gid = grp.getgrnam(group).gr_gid
            elif isinstance(group, int):
                gid = group
            else:
                raise TypeError("Group must be a string or an integer, not {}"
                                .format(type(group)))
    
            if gid &lt; 0:
                raise ValueError(f"Group ID cannot be negative, got {gid}")
    
        gids = None
        if extra_groups is not None:
            if not hasattr(os, 'setgroups'):
                raise ValueError("The 'extra_groups' parameter is not "
                                 "supported on the current platform")
    
            elif isinstance(extra_groups, str):
                raise ValueError("Groups must be a list, not a string")
    
            gids = []
            for extra_group in extra_groups:
                if isinstance(extra_group, str):
                    if grp is None:
                        raise ValueError("Items in extra_groups cannot be "
                                         "strings on systems without the "
                                         "grp module")
    
                    gids.append(grp.getgrnam(extra_group).gr_gid)
                elif isinstance(extra_group, int):
                    gids.append(extra_group)
                else:
                    raise TypeError("Items in extra_groups must be a string "
                                    "or integer, not {}"
                                    .format(type(extra_group)))
    
            # make sure that the gids are all positive here so we can do less
            # checking in the C code
            for gid_check in gids:
                if gid_check &lt; 0:
                    raise ValueError(f"Group ID cannot be negative, got {gid_check}")
    
        uid = None
        if user is not None:
            if not hasattr(os, 'setreuid'):
                raise ValueError("The 'user' parameter is not supported on "
                                 "the current platform")
    
            elif isinstance(user, str):
                if pwd is None:
                    raise ValueError("The user parameter cannot be a string "
                                     "on systems without the pwd module")
    
                uid = pwd.getpwnam(user).pw_uid
            elif isinstance(user, int):
                uid = user
            else:
                raise TypeError("User must be a string or an integer")
    
            if uid &lt; 0:
                raise ValueError(f"User ID cannot be negative, got {uid}")
    
        try:
            if p2cwrite != -1:
                self.stdin = io.open(p2cwrite, 'wb', bufsize)
                if self.text_mode:
                    self.stdin = io.TextIOWrapper(self.stdin, write_through=True,
                            line_buffering=line_buffering,
                            encoding=encoding, errors=errors)
            if c2pread != -1:
                self.stdout = io.open(c2pread, 'rb', bufsize)
                if self.text_mode:
                    self.stdout = io.TextIOWrapper(self.stdout,
                            encoding=encoding, errors=errors)
            if errread != -1:
                self.stderr = io.open(errread, 'rb', bufsize)
                if self.text_mode:
                    self.stderr = io.TextIOWrapper(self.stderr,
                            encoding=encoding, errors=errors)
    
&gt;           self._execute_child(args, executable, preexec_fn, close_fds,
                                pass_fds, cwd, env,
                                startupinfo, creationflags, shell,
                                p2cread, p2cwrite,
                                c2pread, c2pwrite,
                                errread, errwrite,
                                restore_signals,
                                gid, gids, uid, umask,
                                start_new_session)

c:\python39\lib\subprocess.py:951: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;Popen: returncode: None args: ['chromedriver', '--port=56985']&gt;, args = 'chromedriver --port=56985'
executable = None, preexec_fn = None, close_fds = False, pass_fds = (), cwd = None
env = environ({'ALLUSERSPROFILE': 'C:\\ProgramData', 'APPDATA': 'C:\\Users\\vishr\\AppData\\Roaming', 'CHOCOLATEYINSTALL': '...\WINDOWS', 'PYTEST_CURRENT_TEST': 'tests/test_login_page_title.py::TestLoginPageTitle::test_login_page_title (setup)'})
startupinfo = &lt;subprocess.STARTUPINFO object at 0x000001C88E259100&gt;, creationflags = 0, shell = False
p2cread = Handle(800), p2cwrite = 6, c2pread = -1, c2pwrite = Handle(780), errread = -1, errwrite = Handle(816)
unused_restore_signals = True, unused_gid = None, unused_gids = None, unused_uid = None, unused_umask = -1
unused_start_new_session = False

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       unused_restore_signals,
                       unused_gid, unused_gids, unused_uid,
                       unused_umask,
                       unused_start_new_session):
        """Execute program (MS Windows version)"""
    
        assert not pass_fds, "pass_fds not supported on Windows."
    
        if isinstance(args, str):
            pass
        elif isinstance(args, bytes):
            if shell:
                raise TypeError('bytes args is not allowed on Windows')
            args = list2cmdline([args])
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = list2cmdline([args])
        else:
            args = list2cmdline(args)
    
        if executable is not None:
            executable = os.fsdecode(executable)
    
        # Process startup details
        if startupinfo is None:
            startupinfo = STARTUPINFO()
        else:
            # bpo-34044: Copy STARTUPINFO since it is modified above,
            # so the caller can reuse it multiple times.
            startupinfo = startupinfo.copy()
    
        use_std_handles = -1 not in (p2cread, c2pwrite, errwrite)
        if use_std_handles:
            startupinfo.dwFlags |= _winapi.STARTF_USESTDHANDLES
            startupinfo.hStdInput = p2cread
            startupinfo.hStdOutput = c2pwrite
            startupinfo.hStdError = errwrite
    
        attribute_list = startupinfo.lpAttributeList
        have_handle_list = bool(attribute_list and
                                "handle_list" in attribute_list and
                                attribute_list["handle_list"])
    
        # If we were given an handle_list or need to create one
        if have_handle_list or (use_std_handles and close_fds):
            if attribute_list is None:
                attribute_list = startupinfo.lpAttributeList = {}
            handle_list = attribute_list["handle_list"] = \
                list(attribute_list.get("handle_list", []))
    
            if use_std_handles:
                handle_list += [int(p2cread), int(c2pwrite), int(errwrite)]
    
            handle_list[:] = self._filter_handle_list(handle_list)
    
            if handle_list:
                if not close_fds:
                    warnings.warn("startupinfo.lpAttributeList['handle_list'] "
                                  "overriding close_fds", RuntimeWarning)
    
                # When using the handle_list we always request to inherit
                # handles but the only handles that will be inherited are
                # the ones in the handle_list
                close_fds = False
    
        if shell:
            startupinfo.dwFlags |= _winapi.STARTF_USESHOWWINDOW
            startupinfo.wShowWindow = _winapi.SW_HIDE
            comspec = os.environ.get("COMSPEC", "cmd.exe")
            args = '{} /c "{}"'.format (comspec, args)
    
        if cwd is not None:
            cwd = os.fsdecode(cwd)
    
        sys.audit("subprocess.Popen", executable, args, cwd, env)
    
        # Start the process
        try:
&gt;           hp, ht, pid, tid = _winapi.CreateProcess(executable, args,
                                     # no special security
                                     None, None,
                                     int(not close_fds),
                                     creationflags,
                                     env,
                                     cwd,
                                     startupinfo)
E                                    FileNotFoundError: [WinError 2] The system cannot find the file specified

c:\python39\lib\subprocess.py:1420: FileNotFoundError

During handling of the above exception, another exception occurred:

request = &lt;SubRequest 'driver_setup' for &lt;Function test_login_page_title&gt;&gt;

    @pytest.fixture(scope="module")
    def driver_setup(request):
        global driver
        print('-' * 10 + 'Driver - Setup' + '-' * 10)
        browser_name = request.config.getoption("browser_name")
        browser_name = browser_name.upper()
        if browser_name == "CHROME" and s.DOCKER == 'N':
            driver = webdriver.Chrome(ChromeDriverManager().install())
        elif browser_name == "CHROME" and s.DOCKER == 'Y':
            chrome_options = Options()
            chrome_options.add_argument("--headless")
            chrome_options.add_argument("--no-sandbox")
            chrome_options.add_argument("--disable-dev-shm-usage")
            chrome_prefs = {}
            chrome_options.experimental_options["prefs"] = chrome_prefs
            chrome_prefs["profile.default_content_settings"] = {"images": 2}
&gt;           driver = webdriver.Chrome(options=chrome_options)

tests\conftest.py:35: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
c:\python39\lib\site-packages\selenium\webdriver\chrome\webdriver.py:73: in __init__
    self.service.start()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;selenium.webdriver.chrome.service.Service object at 0x000001C88E7648B0&gt;

    def start(self):
        """
        Starts the Service.
    
        :Exceptions:
         - WebDriverException : Raised either when it can't start the service
           or when it can't connect to the service
        """
        try:
            cmd = [self.path]
            cmd.extend(self.command_line_args())
            self.process = subprocess.Popen(cmd, env=self.env,
                                            close_fds=platform.system() != 'Windows',
                                            stdout=self.log_file,
                                            stderr=self.log_file,
                                            stdin=PIPE)
        except TypeError:
            raise
        except OSError as err:
            if err.errno == errno.ENOENT:
&gt;               raise WebDriverException(
                    "'%s' executable needs to be in PATH. %s" % (
                        os.path.basename(self.path), self.start_error_message)
E                       selenium.common.exceptions.WebDriverException: Message: 'chromedriver' executable needs to be in PATH. Please see https://sites.google.com/a/chromium.org/chromedriver/home

c:\python39\lib\site-packages\selenium\webdriver\common\service.py:81: WebDriverException</error></testcase><testcase classname="tests.test_rerun" name="test_num[0]" time="0.001" /><testcase classname="tests.test_rerun" name="test_num[1]" time="0.001" /><testcase classname="tests.test_rerun" name="test_num[2]" time="0.001" /><testcase classname="tests.test_rerun" name="test_num[3]" time="0.001" /><testcase classname="tests.test_rerun" name="test_num[4]" time="0.002" /><testcase classname="tests.test_rerun" name="test_num[5]" time="0.002" /><testcase classname="tests.test_rerun" name="test_num[6]" time="0.002" /><testcase classname="tests.test_rerun" name="test_num[7]" time="0.001" /><testcase classname="tests.test_rerun" name="test_num[8]" time="0.001" /><testcase classname="tests.test_rerun" name="test_num[9]" time="0.002" /><testcase classname="tests.test_rerun" name="test_num[10]" time="0.002" /><testcase classname="tests.test_rerun" name="test_num[11]" time="0.002" /><testcase classname="tests.test_rerun" name="test_num[12]" time="0.002" /><testcase classname="tests.test_rerun" name="test_num[13]" time="0.002" /><testcase classname="tests.test_rerun" name="test_num[14]" time="0.001" /><testcase classname="tests.test_rerun" name="test_num[15]" time="0.002" /><testcase classname="tests.test_rerun" name="test_num[16]" time="0.002" /><testcase classname="tests.test_rerun" name="test_num[17]" time="0.002"><failure message="Failed: bad luck">i = 17

    @pytest.mark.parametrize("i", range(50))
    def test_num(i):
        if i in (17, 25):
&gt;           pytest.fail("bad luck")
E           Failed: bad luck

tests\test_rerun.py:7: Failed</failure></testcase><testcase classname="tests.test_rerun" name="test_num[18]" time="0.002" /><testcase classname="tests.test_rerun" name="test_num[19]" time="0.003" /><testcase classname="tests.test_rerun" name="test_num[20]" time="0.001" /><testcase classname="tests.test_rerun" name="test_num[21]" time="0.002" /><testcase classname="tests.test_rerun" name="test_num[22]" time="0.001" /><testcase classname="tests.test_rerun" name="test_num[23]" time="0.002" /><testcase classname="tests.test_rerun" name="test_num[24]" time="0.001" /><testcase classname="tests.test_rerun" name="test_num[25]" time="0.002"><failure message="Failed: bad luck">i = 25

    @pytest.mark.parametrize("i", range(50))
    def test_num(i):
        if i in (17, 25):
&gt;           pytest.fail("bad luck")
E           Failed: bad luck

tests\test_rerun.py:7: Failed</failure></testcase><testcase classname="tests.test_rerun" name="test_num[26]" time="0.002" /><testcase classname="tests.test_rerun" name="test_num[27]" time="0.001" /><testcase classname="tests.test_rerun" name="test_num[28]" time="0.002" /><testcase classname="tests.test_rerun" name="test_num[29]" time="0.001" /><testcase classname="tests.test_rerun" name="test_num[30]" time="0.001" /><testcase classname="tests.test_rerun" name="test_num[31]" time="0.002" /><testcase classname="tests.test_rerun" name="test_num[32]" time="0.002" /><testcase classname="tests.test_rerun" name="test_num[33]" time="0.002" /><testcase classname="tests.test_rerun" name="test_num[34]" time="0.002" /><testcase classname="tests.test_rerun" name="test_num[35]" time="0.002" /><testcase classname="tests.test_rerun" name="test_num[36]" time="0.001" /><testcase classname="tests.test_rerun" name="test_num[37]" time="0.002" /><testcase classname="tests.test_rerun" name="test_num[38]" time="0.002" /><testcase classname="tests.test_rerun" name="test_num[39]" time="0.001" /><testcase classname="tests.test_rerun" name="test_num[40]" time="0.002" /><testcase classname="tests.test_rerun" name="test_num[41]" time="0.002" /><testcase classname="tests.test_rerun" name="test_num[42]" time="0.002" /><testcase classname="tests.test_rerun" name="test_num[43]" time="0.002" /><testcase classname="tests.test_rerun" name="test_num[44]" time="0.002" /><testcase classname="tests.test_rerun" name="test_num[45]" time="0.002" /><testcase classname="tests.test_rerun" name="test_num[46]" time="0.001" /><testcase classname="tests.test_rerun" name="test_num[47]" time="0.002" /><testcase classname="tests.test_rerun" name="test_num[48]" time="0.001" /><testcase classname="tests.test_rerun" name="test_num[49]" time="0.347" /></testsuite></testsuites>